<?php

namespace AlexisLefebvre\Bundle\AsyncTweetsBundle\Entity;

use Doctrine\ORM\EntityRepository;

/**
 * TweetRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class TweetRepository extends EntityRepository
{
    private $nbTweets = 10;
    
    public function getWithUsers($page = 1)
    {
        $firstResult = (($page - 1) * $this->nbTweets);
                
        $qb = $this->createQueryBuilder('t');
        
        $query = $qb
            ->select('t, user, rt, rt_user')
            ->innerJoin('t.user', 'user')
            ->leftJoin('t.retweeted_status', 'rt')
            ->leftJoin('rt.user', 'rt_user')
            
            // Ignore tweets that were only retweeted
            ->where($qb->expr()->eq('t.in_timeline', 'true'))
            
            ->orderBy('t.id', 'DESC')
            
            ->setFirstResult($firstResult)
            ->setMaxResults($this->nbTweets)
        ;
        
        return $query->getQuery()->getResult();
    }
    
    /**
     * @param \Doctrine\ORM\QueryBuilder $qb
     */
    private function getWithUsersAndMediasQuery($qb)
    {
        $query = $qb
            ->select('t, user, medias, rt, rt_user')
            ->innerJoin('t.user', 'user')
            ->leftJoin('t.medias', 'medias')
            ->leftJoin('t.retweeted_status', 'rt')
            ->leftJoin('rt.user', 'rt_user')
            
            // Ignore tweets that were only retweeted
            ->where($qb->expr()->eq('t.in_timeline', 'true'))
            
            ->orderBy('t.id', 'ASC')
            
            ->setFirstResult(0)
            ->setMaxResults($this->nbTweets)
        ;
        
        return $query;
    }
    
    public function getWithUsersAndMedias($firstTweetId = null)
    {
        $qb = $this->createQueryBuilder('t');
        
        $query = $this->getWithUsersAndMediasQuery($qb);
        
        if (! is_null($firstTweetId))
        {
            $query = $query->andWhere(
                $qb->expr()->gte('t.id', $firstTweetId)
            );
        }
        
        return $query->getQuery()->getResult();
    }
    
    /**
     * @param string $condition
     * @param string $order
     */
    private function getTweetId($condition, $order, $tweetId)
    {
        $qb = $this->createQueryBuilder('t')
            ->select('t.id')
            
            ->where('t.id '.$condition.' :tweetId')
            ->setParameter(':tweetId', $tweetId)
            
            ->andWhere('t.in_timeline = true')
            
            ->orderBy('t.id', $order)
            
            ->setFirstResult($this->nbTweets - 1)
            ->setMaxResults(1)
        ;
        
        $result = $qb->getQuery()->getOneOrNullResult();
        
        return($this->getIdOrNull($result));
    }
    
    private function getIdOrNull($result)
    {
        return(is_array($result) ? $result['id'] : null);
    }
    
    public function getPreviousAndNextTweetId($tweetId)
    {
        return(array(
            $this->getTweetId('<', 'DESC', $tweetId),
            $this->getTweetId('>', 'ASC', $tweetId)
        ));
    }
    
    public function countPendingTweets($lastTweetId = null)
    {
        $qb = $this->createQueryBuilder('t');
        
        $query = $qb
            ->add('select', $qb->expr()->count('t.id'))
            // Ignore tweets that were only retweeted
            ->where(
                $qb->expr()->eq('t.in_timeline', 'true')
            )
        ;
        
        if (! is_null($lastTweetId))
        {
            $query = $query->andWhere(
                $qb->expr()->gte('t.id', $lastTweetId)
            );
        }
        
        # return result of "COUNT()" query
        return $query->getQuery()->getSingleScalarResult();
    }
    
    public function getLastTweet()
    {
        $qb = $this->createQueryBuilder('t')
            ->addOrderBy('t.id', 'DESC')
            ->setFirstResult(0)
            ->setMaxResults(1)
        ;
        
        return $qb->getQuery()->getOneOrNullResult();
    }
    
    /**
     * @param integer $tweetId
     */
    private function getTweetsLessThanId($tweetId)
    {
        $qb = $this->createQueryBuilder('t')
            ->select('t, m')
            ->leftJoin('t.medias', 'm')
            ->where('t.id < :tweetId')
            ->setParameter(':tweetId', $tweetId)
            
            // Get retweeted tweets (it would break foreign keys)
            //  http://stackoverflow.com/questions/15087933/how-to-do-left-join-in-doctrine/15088250#15088250
            ->leftJoin(
                'AsyncTweetsBundle:Tweet',
                't2',
                'WITH',
                't.id = t2.retweeted_status'
            )
            
            ->orderBy('t.id', 'DESC')
        ;
        
        return($qb->getQuery()->getResult());
    }
    
    /**
     * Remove Media not associated to any Tweet
     */
    private function removeOrphanMedias(Media $media)
    {
        if (count($media->getTweets()) == 0)
        {
            $this->_em->remove($media);
        }
    }
    
    /**
     * Remove the tweet and return 1 is the deleted tweet is not a
     *  retweet
     * 
     * @param Tweet $tweet
     * 
     * @return integer
     */
    protected function removeTweet($tweet)
    {
        $count = 0;
        
        foreach ($tweet->getMedias() as $media) {
            $tweet->removeMedia($media);
            $this->removeOrphanMedias($media);
        }
        
        // Don't count tweets that were only retweeted
        if ($tweet->isInTimeline()) {
            $count = 1;
        }
        
        $this->_em->remove($tweet);
        
        return $count;
    }
    
    /**
     * Delete tweets and return the number of deleted tweets (excluding
     *  retweeted-only tweets)
     * 
     * @param integer $tweetId
     * 
     * @return integer
     */
    public function deleteAndHideTweetsLessThanId($tweetId)
    {
        $count = 0;
        
        foreach ($this->getTweetsLessThanId($tweetId) as $tweet) {
            // The Tweet has not been retweeted, it can be removed
            if (count($tweet->getRetweetingStatuses()) == 0) {
                $count += $this->removeTweet($tweet);
            }
            else {
                $delete = false;
                
                foreach ($tweet->getRetweetingStatuses() as $retweeting_status) {
                    if ($retweeting_status->getId() < $tweetId) {
                        $delete = true;
                        break;
                    }
                }
                
                // The Tweet can be deleted
                if ($delete) {
                    $count += $this->removeTweet($tweet);
                }
                // The Tweet is still in the timeline, it can only be hidden
                else {
                    $tweet->setInTimeline(false);
                    $this->_em->persist($tweet);
                }
            }
        }
        
        $this->_em->flush();
        
        return($count);
    }
}
